<h1 id="handy-functions-of-http-">Handy functions of <code>http</code></h1>
<h2 id="-http-maxbytesreader-"><code>http.MaxBytesReader</code></h2>
<p>When you need to set limit to the <code>POST</code> body size of an endpoint. For instance, in a file upload
  endpoint, you can use this function to set a limit on the size of file sent by a client.</p>
<h3 id="signature">Signature</h3>
<pre><code class="lang-go">func MaxBytesReader(w http<span class="hljs-selector-class">.ResponseWriter</span>, r io<span class="hljs-selector-class">.ReadCloser</span>, n int64) io.ReadCloser
</code></pre>
<h3 id="usage-scenario">Usage scenario</h3>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/upload"</span>, func(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http.Request) {
  <span class="hljs-selector-tag">var</span> fileSizeLimit int64 = <span class="hljs-number">10</span>

  r<span class="hljs-selector-class">.Body</span> = http.MaxBytesReader(w, r<span class="hljs-selector-class">.Body</span>, fileSizeLimit)

  defer r<span class="hljs-selector-class">.Body</span><span class="hljs-selector-class">.Close</span>()

  data, err := io.ReadAll(r.Body)

  <span class="hljs-comment">// incomplete read data</span>
  fmt.Printf(<span class="hljs-string">"%s\n"</span>, data)

  <span class="hljs-keyword">if</span> err != nil {
   <span class="hljs-selector-tag">var</span> mbe *http<span class="hljs-selector-class">.MaxBytesError</span>

   <span class="hljs-keyword">if</span> errors.As(err, &amp;mbe) {
    w.WriteHeader(http.StatusRequestEntityTooLarge)
    fmt.Fprintf(w, <span class="hljs-string">"File too large. Limit is %d bytes.\n"</span>, fileSizeLimit)
    return
   }
   w.WriteHeader(<span class="hljs-number">500</span>)
   fmt.Fprintln(w, <span class="hljs-string">"Internal Server Error"</span>)
   return
  }

  fmt.Fprintln(w, <span class="hljs-string">"Upload success!"</span>)
})
</code></pre>
<h3 id="test">Test</h3>
<p>This client tries to send a text file with more than ten ascii characters.</p>
<pre><code class="lang-bash">curl --data <span class="hljs-meta">@tenpluschars</span>.txt <span class="hljs-string">http:</span><span class="hljs-comment">//localhost:5000/upload</span>
</code></pre>
<h2 id="-http-servecontent-"><code>http.ServeContent</code></h2>
<p>This function, in one line, takes complete care of conditional and range requests for a resource. You don&#39;t have
  to program for any conditional or range header specified in the request header as this function takes care it all. All
  you have to do is hand-over the content that would normally be received from that endpoint.</p>
<p>This is particulary useful for media streaming. Media streaming services like YouTube and even the HTML
  <code>&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</code> element use Range Requests for media streaming. They request
  small portions of the content for early consumption.</p>
<p>This functions takes care of the neccessary status codes (200, 304, 206) and headers to be sent for both conditional
  and range requests.</p>
<h3 id="signature">Signature</h3>
<pre><code class="lang-go"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">ServeContent</span>(<span class="hljs-selector-tag">w</span> <span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.ResponseWriter</span>, <span class="hljs-selector-tag">req</span> *<span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.Request</span>, <span class="hljs-selector-tag">name</span> <span class="hljs-selector-tag">string</span>, <span class="hljs-selector-tag">modtime</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Time</span>, <span class="hljs-selector-tag">content</span> <span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.ReadSeeker</span>)
</code></pre>
<h3 id="usage-scenario">Usage scenario</h3>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/myfiles/note"</span>, func(w http.ResponseWriter, r *http.Request) {

  <span class="hljs-keyword">file</span>, <span class="hljs-keyword">err</span> := os.<span class="hljs-keyword">Open</span>(<span class="hljs-string">"note.md"</span>)
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil {
   fmt.Fprintln(os.Stderr, <span class="hljs-keyword">err</span>)
   w.WriteHeader(500)
   fmt.Fprintln(w, <span class="hljs-string">"Internal Server Error"</span>)
   <span class="hljs-built_in">return</span>
  }

  defer <span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()

  fileStat, _ := <span class="hljs-keyword">file</span>.Stat()

  http.ServeContent(w, r, fileStat.Name(), fileStat.ModTime(), <span class="hljs-keyword">file</span>)
 })
</code></pre>
<p>Note that, our endpoint URL has nothing to do with the resource sent. Any endpoint URL can be specified. Any resource
  can be sent.</p>
<h3 id="test">Test</h3>
<p>This client executes a conditional request based on last modified time (as usual). Our function then decides whether
  to serve the response or not.</p>
<p>The <code>bash</code> command below sends a conditional request, using the date specified in the request&#39;s
  <code>If-Modified-Since</code> header.</p>
<pre><code class="lang-bash">curl -z <span class="hljs-string">"Tue, 25 Jun 2024 17:00:00 GMT"</span> http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">5000</span><span class="hljs-regexp">/myfiles/</span>notes.md
</code></pre>
<h3 id="test-2">Test 2</h3>
<p>Try sending a video this time. Run in the browser an HTML file having a <code>video</code> element whose
  <code>src</code> points to the specified endpoint URL. Now inspect your network motitor. Notice in the header tab, how
  the browser uses range request headers to request for portions of the video data $-$ even when you seek forward and
  backward in the video. The <code>http.ServeContent</code> saves you the stress of responding accordingly.</p>
<h2 id="-http-servefile-"><code>http.ServeFile</code></h2>
<p>A more concise version of <code>http.ServeContent</code>, with the following differences:</p>
<ul>
  <li>It treats a URL path ending in <code>/index.html</code> specially by redirecting to the path without
    <code>/index.html</code>. It assumes an <code>index.html</code> file wants to be served (and most implementations
    hide the ending <code>/index.html</code> in these situation). And like <code>http.ServeContent</code>, the resource
    served has nothing to do with the endpoint URL specified. Any type of resource can be served $-$ even in this case.
  </li>
  <li>It is best for serving files from the file system $-$ one liner. <code>http.ServeContent</code>, however, allows
    serving any type that implements the <code>io.ReadSeeker</code> interface; it doesn&#39;t have to be a file from the
    file system. <code>http.ServeContent</code> is therefore, more flexible.</li>
</ul>
<h3 id="signature">Signature</h3>
<pre><code class="lang-go">func ServeFile(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http<span class="hljs-selector-class">.Request</span>, pathtofile string)
</code></pre>
<h3 id="usage-scenario">Usage scenario</h3>
<pre><code class="lang-go"><span class="hljs-keyword">http</span>.HandleFunc(<span class="hljs-string">"/myfiles/note"</span>, func(w <span class="hljs-keyword">http</span>.ResponseWriter, r *<span class="hljs-keyword">http</span>.Request) {
  <span class="hljs-keyword">http</span>.ServeFile(w, r, <span class="hljs-string">"/path/to/file"</span>)
})
</code></pre>
<h2 id="-http-dir-"><code>http.Dir</code></h2>
<p><code>http.Dir</code> makes a <code>FileSystem</code> out the specified native file system directory path you
  specify.</p>
<p>You can read the files, root and sub-directories in the created <code>FileSystem</code> with its <code>Open()</code>
  method or pass it directly to an implementation that accepts a <code>FileSystem</code> interface, mostly
  <code>http.FileServer</code> $-$ addressed below. This is particularly useful in web servers.</p>
<h3 id="usage">Usage</h3>
<pre><code class="lang-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpDirUsage</span><span class="hljs-params">()</span></span> {
  home, _ := os.UserHomeDir()

  dir := http.Dir(home + <span class="hljs-string">"/www"</span>) <span class="hljs-comment">// makes the "www" directory into a file system</span>
  htmlFile, _ := dir.Open(<span class="hljs-string">"index.html"</span>)

  <span class="hljs-keyword">defer</span> htmlFile.Close()

  data, _ := io.ReadAll(htmlFile)

  cssFolder, _ := dir.Open(<span class="hljs-string">"css"</span>)
  fileInfos, _ := cssFolder.Readdir(<span class="hljs-number">0</span>) <span class="hljs-comment">// 0 means - no limit</span>
  <span class="hljs-comment">// fileInfos is a slice of file or folder information contained in the css folder</span>
  <span class="hljs-comment">// check the package documentation to see how you can utilize it</span>
}
</code></pre>
<h2 id="-http-fileserver-"><code>http.FileServer</code></h2>
<p>What do you (&quot;john&quot; - for example) think happens when you deploy your <code>build</code> folder on hosting
  sites like Netlify.</p>
<p>In the remote server file system, a folder (<code>john_website</code> - for instance) containing the contents of your
  <code>build</code> folder (if not, actually, your build folder) is directly pointed to by your domain&#39;s root path.
</p>
<p>Precisely, the handler that hanldes the request to your domain is this <code>http.FileServer</code> (or equivalent
  function in other languages). It, basically, treats your website folder as a single file system.</p>
<h3 id="signature">Signature</h3>
<pre><code class="lang-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileServer</span><span class="hljs-params">(root http.FileSystem)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span>
</code></pre>
<h3 id="usage-scenario">Usage scenario</h3>
<p>Say, your build folder contains the usual <code>index.html</code>, accompanied by subpages, CSS, JS files and folders
  containing them $-$ the usual thing. On deployment, the contents have now being transferred to a
  <code>{username}_website</code> folder.</p>
<pre><code class="lang-go">johnWebFS := http.Dir(<span class="hljs-string">"/home/netlify/www/john_wesbite"</span>)

http.ListenAndServe(<span class="hljs-string">"funcoding.netlify.app"</span>, http.FileServer(johnWebFS))
</code></pre>
<p>One line, and your website is up and running.</p>
<blockquote>
  <p>That&#39;s just for our explanation, of course, you should change the parameters if you&#39;re trying this out</p>
</blockquote>
<pre><code class="lang-go">myWebFS := http.Dir(<span class="hljs-string">"path/to/www/folder"</span>)

http.ListenAndServe(<span class="hljs-string">"localhost:5000"</span>, http.FileServer(myWebFS))
</code></pre>
<h3 id="test">Test</h3>
<p>The usual website browsing. Just goto <code>https://funcoding.netlify.app</code>. Actually,
  <code>http://localhost:5000</code> in our case.</p>
<h2 id="-http-responsewriter-write-"><code>(http.ResponseWriter).Write()</code></h2>
<p>The famous <code>Write()</code> method??? Who doesn&#39;t know what that does?</p>
<p>Yeah, we all know what it does. But what it really does and how it does it is what&#39;s intriguing.</p>
<p>This <code>Write()</code> method actually &quot;streams&quot; data to the client &quot;in chunks&quot; and sets
  <code>Transfer-Encoding: &quot;chunked&quot;</code> header. It doesn&#39;t transfer whole data to the client at once.
  A 1gb video data is contained in a byte slice, for instance, will be sent in chunks. Try inspecting your browser&#39;s
  network monitor, you&#39;ll see a <em>&quot;CAUTION: request is not finished yet!&quot;</em> warning, and you&#39;ll
  notice the amount of data transfered (bottom-left) is far from 1gb. In fact, pausing the video also pauses the data
  transfer.</p>
<p>This original size of this video below is 26.7mb. The amount of data transfer below is just 7.3mb.</p>
<p><img src="./proof.png" alt="Video streaming"></p>
<p>Another interesting behaviour is that, you can queue more <code>Write([]byte)</code> methods anywhere before the
  handler returns and the data in the byte slice will be pushed to the buffer, after the previous content pushed by
  previous <code>Write([]byte)</code> calls have been flushed to the client. Until our handler returns, the browser
  network monitor will still display <em>&quot;CAUTION: request is not finished yet!&quot;</em> in between the calls to
  <code>Write([]byte)</code>. It is, however, important to note that additional <code>Write([]byte)</code> calls will
  assume the <code>Content-Type</code> of the first.</p>
<p>Consider this demonstration below:</p>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/mynotes"</span>, func(w http.ResponseWriter, r *http.Request) {
  <span class="hljs-keyword">notes</span>, <span class="hljs-keyword">err</span> := os.ReadFile(<span class="hljs-string">"notes.md"</span>)
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil {
   w.WriteHeader(500)
   fmt.Fprintln(w, <span class="hljs-string">"Error reading file:"</span>, <span class="hljs-keyword">err</span>)
   <span class="hljs-built_in">return</span>
  }

  w.Write(<span class="hljs-keyword">notes</span>)

  <span class="hljs-comment">// the browser network motitor will still display, "CAUTION: request is not finished yet!"</span>
  time.<span class="hljs-keyword">Sleep</span>(3 * time.Second)

  html, <span class="hljs-keyword">err</span> := os.ReadFile(<span class="hljs-string">"website/index.html"</span>)
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil {
    w.WriteHeader(500)
   fmt.Fprintln(w, <span class="hljs-string">"Error reading file:"</span>, <span class="hljs-keyword">err</span>)
   <span class="hljs-built_in">return</span>
  }
  w.Write([]byte(<span class="hljs-string">"\n❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤\n\n"</span>))

  <span class="hljs-comment">// this will be treated as text/plain, not text/html</span>
  w.Write(html)

 })
</code></pre>
<h2 id="form-handling">Form handling</h2>
<h3 id="-http-request-parsemultipartform-"><code>(http.Request).ParseMultipartForm</code></h3>
<p>Before we can start getting form values and files from our request, we first must parse them from the request body.
</p>
<p>This request method parses the body, up to the size specified in <code>maxMemory</code>, into memory (containing
  usable data). The remaining data beyond <code>maxMemory</code> is stored on disk (unsuable).</p>
<h4 id="signature">Signature</h4>
<pre><code class="lang-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *http.Request)</span> <span class="hljs-title">ParseMultipartForm</span><span class="hljs-params">(maxMemory int64)</span> <span class="hljs-title">error</span></span>
</code></pre>
<p>Note that, the <code>maxMemory</code> specified isn&#39;t intend to set the body read limit. If you want to set the
  body read limit, thereby allowing this function to return error when body read limit is reached, you have to use
  <code>http.MaxBytesReader(r.Body)</code> like we discussed above.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-go">// <span class="hljs-keyword">set</span> r.Body
http.HandleFunc(<span class="hljs-string">"/profile"</span>, func(w http.ResponseWriter, r *http.Request) {
  <span class="hljs-keyword">limit</span> := <span class="hljs-number">100</span> // <span class="hljs-number">100</span> bytes.
  // Practically, <span class="hljs-keyword">use</span> an estimate <span class="hljs-keyword">of</span> the allowed maximum <span class="hljs-keyword">file</span> <span class="hljs-keyword">size</span> (<span class="hljs-keyword">sum</span> <span class="hljs-keyword">of</span>, <span class="hljs-keyword">if</span> multiple) plus an estimate <span class="hljs-keyword">size</span> <span class="hljs-keyword">for</span> other <span class="hljs-keyword">form</span> <span class="hljs-keyword">data</span>

  r.Body = http.MaxBytesReader(w, r, <span class="hljs-keyword">limit</span>) // recommended

  err := r.ParseMultipartForm(<span class="hljs-keyword">limit</span>) // <span class="hljs-keyword">Of</span> course, why <span class="hljs-keyword">allocate</span> more <span class="hljs-keyword">than</span> <span class="hljs-keyword">body</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">limit</span>
  // <span class="hljs-keyword">if</span> <span class="hljs-keyword">body</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">limit</span> <span class="hljs-keyword">is</span> reached <span class="hljs-keyword">while</span> parsing, this <span class="hljs-keyword">error</span> would be: <span class="hljs-string">"http: request body too large"</span>
})
</code></pre>
<p>After successful parsin, request properties and methods that provide access to form data will now have expected data.
  Lets take a look into these properties and methods.</p>
<h3 id="-http-request-formvalue-"><code>(http.Request).FormValue</code></h3>
<p>For a non-file type form field, this function gets the first of <code>n</code> value associated with the given key.
</p>
<p>A file type form field is treated as non-existent.</p>
<h4 id="signature">Signature</h4>
<pre><code class="lang-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*http.Request)</span> <span class="hljs-title">FormValue</span><span class="hljs-params">(key string)</span> <span class="hljs-title">string</span></span>
</code></pre>
<h4 id="usage">Usage</h4>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/profile"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
  r.ParseMultipartForm(maxMemory)

  uname := r.FormValue(<span class="hljs-string">"username"</span>)

  fmt.Println(uname) <span class="hljs-comment">// i9 (as tested below)</span>
})
</code></pre>
<h4 id="test">Test</h4>
<pre><code class="lang-bash">curl --form username=i9 age=<span class="hljs-number">23</span> <span class="hljs-string">http:</span><span class="hljs-string">localhost:</span><span class="hljs-number">5000</span>/profile
</code></pre>
<h3 id="-http-request-form-"><code>(http.Request).Form</code></h3>
<p><code>(http.Request).Form</code> has an underlying <code>map[string][]string</code> that contains form fields of
  types other than &quot;file&quot; i.e. form fields of type &quot;file&quot; are excluded from the map.</p>
<p>It exposes methods to access and modify the <code>Form</code> (in case of a outbound request). The only method
  we&#39;ll need in our case (inbound request) is the <code>Get()</code> method, which returns the first of
  <code>n</code> values associated with a given key.</p>
<p>Another way is to iterate the <code>key=[values...]</code> pairs of the underlying map. This way you can get all the
  values associated with a key in a slice.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/profile"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
  err := r.ParseMultipartForm(maxMemory)
  <span class="hljs-comment">// handle error appropriately</span>

  age := r.Form.Get(<span class="hljs-string">"age"</span>)
  fmt.Println(age) <span class="hljs-comment">// 23 (as tested below)</span>

  <span class="hljs-comment">// iterate over the map</span>
  <span class="hljs-keyword">for</span> key, values := <span class="hljs-keyword">range</span> r.Form {
    fmt.Printf(<span class="hljs-string">"%s: %s\n"</span>, key, value[<span class="hljs-number">0</span>])
  }
})
</code></pre>
<h4 id="test">Test</h4>
<pre><code class="lang-bash">curl --form username=i9 age=<span class="hljs-number">23</span> <span class="hljs-string">http:</span><span class="hljs-string">localhost:</span><span class="hljs-number">5000</span>/profile
</code></pre>
<h3 id="-http-request-formfile-"><code>(http.Request).FormFile</code></h3>
<p>If the <code>Form</code> contains only non-file field types, then <code>FormFile</code> contains only file field
  types. This function gets the first of <code>n</code> files associated with the specified key.</p>
<h4 id="signature">Signature</h4>
<pre><code class="lang-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*http.Request)</span> <span class="hljs-title">FormFile</span><span class="hljs-params">(key string)</span> <span class="hljs-params">(multipart.File, *multipart.FileHeader, error)</span></span>
</code></pre>
<p>The <code>multipart.File</code> is a <code>Reader</code> representing the file. The
  <code>*multipart.FileHeader</code> allows us to read the file properties like filename, size, and header. It also has
  an <code>Open()</code> method that returns the same <code>multipart.File</code>.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/profile"</span>, func(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http.Request) {
  err := r.ParseMultipartForm(maxMemory)
  <span class="hljs-comment">// handle error appropriately</span>

  f, fh, _ := r.FormFile(<span class="hljs-string">"pic"</span>)

  defer f.Close()

  fmt.Println(fh<span class="hljs-selector-class">.Filename</span> <span class="hljs-comment">/* mypic.png */</span>, fh<span class="hljs-selector-class">.Header</span><span class="hljs-selector-class">.Get</span>(<span class="hljs-string">"Content-Type"</span>) <span class="hljs-comment">/* multipart/form-data */</span>)

  data, _ := io.ReadAll(f)

  <span class="hljs-comment">// just a usage example</span>
  os.WriteFile(<span class="hljs-string">"path/to/storage/"</span>+fh<span class="hljs-selector-class">.filename</span>, data, os.ModePerm) <span class="hljs-comment">// keep in native file system</span>
})
</code></pre>
<h4 id="test">Test</h4>
<pre><code class="lang-bash">curl --<span class="hljs-selector-tag">form</span> pic=@mypic<span class="hljs-selector-class">.png</span> username=i9 age=<span class="hljs-number">23</span> http:localhost:<span class="hljs-number">5000</span>/profile
</code></pre>
<h3 id="-http-request-multipartform">`(http.Request).MultipartForm</h3>
<p><code>MultipartForm</code> has</p>
<ul>
  <li>a <code>File</code> object with an underlying <code>map[string][]*multipart.FileHeader</code> type, and</li>
  <li>a <code>Value</code> object with an underlying <code>map[string][]string</code> type</li>
</ul>
<p>The first is similar to <code>FormFile</code> and the second is similar to <code>Form</code>. However, you work
  directly with the underlying map, there are no methods exposed.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/profile"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
  err := r.ParseMultipartForm(maxMemory)
  <span class="hljs-comment">// handle error appropriately</span>

  filehs := r.MultipartForm.File[<span class="hljs-string">"pic"</span>]
  <span class="hljs-keyword">for</span> _, fileh := <span class="hljs-keyword">range</span> filehs {
    file, _ := fileh.Open()

    <span class="hljs-keyword">defer</span> file.Close()

    data, _ := io.ReadAll(file)
    <span class="hljs-comment">// use data</span>
  }

  <span class="hljs-keyword">for</span> key, filehs := <span class="hljs-keyword">range</span> r.MultipartForm.File {
    <span class="hljs-keyword">for</span> _, fileh := <span class="hljs-keyword">range</span> filehs {
      file, _ := fileh.Open()

      <span class="hljs-keyword">defer</span> file.Close()

      data, _ := io.ReadAll(file)
      <span class="hljs-comment">// use data</span>
    }
  }

  name := r.MultipartForm.Value[<span class="hljs-string">"name"</span>][<span class="hljs-number">0</span>]

  <span class="hljs-keyword">for</span> key, values := <span class="hljs-keyword">range</span> r.MultipartForm.Value {
    name := values[<span class="hljs-number">0</span>]
  }
})
</code></pre>
<h4 id="test">Test</h4>
<pre><code class="lang-bash">curl --<span class="hljs-selector-tag">form</span> pic=@mypic<span class="hljs-selector-class">.png</span> username=i9 age=<span class="hljs-number">23</span> http:localhost:<span class="hljs-number">5000</span>/profile
</code></pre>
<h2 id="streaming-responses-with-http-flusher-flush-">Streaming responses with <code>(http.Flusher).Flush()</code></h2>
<p><code>(http.Flusher).Flush()</code> extension of the <code>http.ResponseWriter</code> allows us to immediately send
  any data buffered by <code>(http.ResponseWriter).Write()</code> over to the client. Implicitly, data is flushed to the
  client either when the buffer contains enough data or when the handler function returns. This function does explicit
  flushing.</p>
<h3 id="signature">Signature</h3>
<p>The response writer (concrete type) currently present in the <code>http.ResponseWriter</code> interface implementes
  both <code>http.ResponseWriter</code> and <code>http.Flusher</code> (i.e. it is both a response writer and a flusher).
  But as we know, an interface hides all the methods of its concrete type except the ones that the interface exposes
  (i.e. the ones that satisfy it), and here, the <code>Flush()</code> method is hidden by
  <code>http.ResponseWriter</code> as the interface doesn&#39;t expose it (i.e. it doesn&#39;t satisfy the interface).
</p>
<p>To expose the <code>Flush()</code> method of the response writer (concrete type) in <code>http.ResponseWriter</code>
  interface, we need to assert <code>http.Flusher</code> on the interface. Doing this does nothing expect to change the
  interface holding the response writer (concrete type) from <code>http.ResponseWriter</code> to
  <code>http.Flusher</code>, and, as expected, <code>http.Flusher</code> hides other methods of the response writer
  (concrete type) except for <code>Flush()</code>, which is exactly what we need at this time.</p>
<pre><code class="lang-go"><span class="hljs-comment">// where `w` is the http.ResponseWriter of the http handler function</span>
flusher, ok := w.<span class="hljs-comment">(http.Flusher)</span> <span class="hljs-comment">// recommended: not all response writers are flushers</span>
<span class="hljs-keyword">if</span> !ok {
  <span class="hljs-comment">// sorry can't stream</span>
} else {
  flusher.Flush<span class="hljs-comment">()</span> <span class="hljs-comment">// response writer is a flusher</span>
}
</code></pre>
<h3 id="usage">Usage</h3>
<p>In this example we are going to stream a text file line-by-line to the client, at intervals. So you should see cURL
  printing the text content one line each after the specified time, allowing us to perceive the &quot;streaming&quot;
  behaviour.</p>
<pre><code class="lang-go">http.HandleFunc(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {

  notesFile, err := os.Open(<span class="hljs-string">"notes.md"</span>)
  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
   log.Println(err)
   w.WriteHeader(<span class="hljs-number">500</span>)
   <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">defer</span> notesFile.Close()

  flusher, ok := w.(http.Flusher)
  <span class="hljs-keyword">if</span> !ok {
   log.Println(<span class="hljs-string">"flusher is not implemented"</span>)
   w.WriteHeader(<span class="hljs-number">500</span>)
   <span class="hljs-keyword">return</span>
  }

  scanner := bufio.NewScanner(notesFile)

  scanner.Split(bufio.ScanLines) <span class="hljs-comment">//default: scan line-by-line</span>

  <span class="hljs-keyword">for</span> scanner.Scan() {
   _, w_err := w.Write(scanner.Bytes())
   <span class="hljs-keyword">if</span> w_err != <span class="hljs-literal">nil</span> {
    log.Println(err)
    <span class="hljs-keyword">return</span>
   }

   <span class="hljs-comment">// bufio.ScanLines strips the ending new line character, so we add it back for expected result</span>
   w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"\n"</span>))

   <span class="hljs-comment">// wait for 0.2 seconds before flushing to perceive the streaming behaviour on the client output</span>
   time.Sleep(<span class="hljs-number">200</span> * time.Millisecond)
   flusher.Flush()
  }
 })
</code></pre>
<p>By default, <code>bufio.NewScanner</code> uses the <code>ScanLines</code> split function, which scans the text file
  line-by-line.</p>
<p>Another option is <code>ScanBytes</code>, which scans the text file character-by-character, allowing us to achieve
  <u>the popular ChatGPT response behaviour</u>. To see that in effect, modify the above code as shown below</p>
<pre><code class="lang-go"><span class="hljs-comment">// change</span>
<span class="hljs-selector-tag">scanner</span><span class="hljs-selector-class">.Split</span>(bufio.ScanLines)
<span class="hljs-comment">// to</span>
<span class="hljs-selector-tag">scanner</span><span class="hljs-selector-class">.Split</span>(bufio.ScanBytes)
<span class="hljs-comment">// ---------</span>
<span class="hljs-comment">// remove</span>
<span class="hljs-selector-tag">w</span><span class="hljs-selector-class">.Write</span>([]byte(<span class="hljs-string">"\n"</span>))
<span class="hljs-comment">// "\n" is a character, it is not stripped</span>
</code></pre>
<blockquote>
  <p><strong>Warning!!!</strong> Don&#39;t use <code>Flush()</code> for real-world audio/video streaming.
    <code>Flush()</code> is intended for sending large size data (that is meant to be consumed once) <em>in chunks</em>
    until it is completely transffered. Real-world audio/video streaming uses Range-Requests, where data is requested in
    portions at any part of the audio/video.\
    \
    Try using <code>Flush()</code> to send a video in chunks. You&#39;ll observe that you can&#39;t achieve the
    &quot;seeking&quot; behaviour (skipping forward or backward). The video will play till the end and stop, unless you
    restart it, in which case it requests the video again. This is just like the text file example above, it is sent
    once and consumed once.\
    \
    In contrast, if you use range requests for the video (the default implementation in browsers and http servers $-$
    <code>http.ServeContent</code>), you&#39;ll be able to seek forward and backward, each performing a new range
    request.</p>
</blockquote>